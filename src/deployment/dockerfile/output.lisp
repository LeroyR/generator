;;;; output.lisp --- Transform instances of model classes into a Dockerfile.
;;;;
;;;; Copyright (C) 2018-2022 Jan Moringen
;;;;
;;;; Author: Jan Moringen <jmoringe@techfak.uni-bielefeld.de>

(cl:in-package #:build-generator.deployment.dockerfile)

;;; Output utilities

(defun write-copy-and-run-commands (stream script-directory scripts)
  (format stream "COPY ~{~A~^ ~} /tmp/~A~@
                    ~@
                    ~{~{~
                      # ~A~@
                      RUN mkdir -p \"~A\" \\~@
                      ~4@T&& cd \"~:*~A\" \\~@
                      ~4@T&& sh \"/tmp/~A\" \\~@
                      ~4@T&& rm \"/tmp/~:*~A\"
                    ~}~^~2%~}"
          (map 'list #'third scripts) script-directory scripts))

(defun make-script-directory (sub-directory)
  (let ((name (util:safe-name sub-directory)))
    (make-pathname :directory `(:relative "scripts" ,name))))

(defun make-script-name (name script-directory output-directory)
  (let* ((script/relative (make-pathname :name      (util:safe-name name)
                                         :type      "sh"
                                         :defaults  script-directory))
         (script/absolute (merge-pathnames script/relative output-directory)))
    (values script/relative script/absolute)))

(defun call-with-output-to-script (continuation name
                                   script-directory output-directory)
  (let+ (((&values relative-name absolute-name)
          (make-script-name name script-directory output-directory)))
    (ensure-directories-exist absolute-name)
    (with-output-to-file (stream absolute-name :if-exists :supersede)
      (format stream "set -e~2%")
      (funcall continuation stream))
    (values relative-name absolute-name)))

(defmacro with-output-to-script ((stream-var name script-directory output-directory)
                                 &body body)
  `(call-with-output-to-script (lambda (,stream-var) ,@body)
                               ,name ,script-directory ,output-directory))

;;; Context
;;;
;;; Information regarding the output target and global configuration
;;; that should be available in all output operations.

(defclass context ()
  ((%directory    :initarg :directory
                  :reader  directory)
   (%dockerfile   :initarg :dockerfile
                  :reader  dockerfile)
   (%run-strategy :initarg :run-strategy
                  :reader  run-strategy)))

(defclass stream-context ()
  ((%parent :initarg :parent
            :reader  parent)
   (%stream :initarg :stream
            :reader  stream1)))

(defmethod directory ((context stream-context))
  (directory (parent context)))

(defmethod dockerfile ((context stream-context))
  (dockerfile (parent context)))

(defmethod run-strategy ((context stream-context))
  (run-strategy (parent context)))

;;; Output for `dockerfile'

(defmethod output ((object dockerfile) (context context))
  (let ((filename (dockerfile context)))
    (ensure-directories-exist filename)
    (with-output-to-file (stream filename :if-exists :supersede)
      (output object (make-instance 'stream-context :parent context
                                                    :stream stream)))))

(defmethod output ((object dockerfile) (context stream-context))
  ;; Header comment and base image.
  (deploy:print-heading
   (stream1 context) "This file is automatically generated.")

  (map nil (rcurry #'output context) (stages object)))

;;; Output for `stage'

(defmethod output ((object stage-mixin) (context stream-context))
  (let ((stream (stream1 context)))
    ;; Write scripts and RUN directives for project builders.
    (map nil (lambda (step)
               (with-simple-restart
                   (continue "~@<Skip writing commands for ~A~@:>" step)
                 (output step context)
                 (format stream "~2%")))
         (steps object))))

(defmethod output ((object pseudo-stage) (context stream-context))
  (let ((stream (stream1 context)))
    (format stream "FROM ~A~2%" (base-image object)))

  (call-next-method))

(defmethod output ((object stage) (context stream-context))
  (let ((stream (stream1 context))
        (name   (model:name object)))
    (deploy:print-heading stream (format nil "Stage ~A" name))
    (format stream "FROM ~A~@[ as ~A~]~2%" (base-image object) name))

  (call-next-method))

;;; `command-step'

(defmethod output ((object command-step) (context stream-context))
  (let ((stream (stream1 context)))
    (deploy:print-heading stream (title object))
    (format stream "RUN ~A~%" (deploy:command object))))

;;; `script-step'

(defmethod output ((object script-step) (context stream-context))
  (let+ ((stream (stream1 context))
         ((&accessors-r/o (name model:name) title (command deploy:command))
          object))
    (deploy:print-heading stream title)
    (write-scripts-and-run-commands*
     `((,name ,title ,command)) "global" context)
    (format stream "~2%")))

;;; `copy-step'

(defmethod output ((object copy-step) (context stream-context))
  (let+ ((stream (stream1 context))
         ((&accessors-r/o from-stage source target) object)
         (from-name (model:name from-stage)))
    (deploy:print-heading stream (format nil "Copy results from stage ~A"
                                         from-name))
    (format stream "COPY --from=~A \"~A\" \"~A\"~%"
            from-name source target)))

;;; `dockerfile-job'

(defmethod output ((object dockerfile-job) (context stream-context))
  (deploy:print-heading (stream1 context) (model:name object))
  (let ((run-strategy (run-strategy context)))
    (write-scripts-and-run-commands object run-strategy context)))

;;; Scripts

(defun write-scripts-and-run-commands* (steps sub-directory context)
  (let ((stream           (stream1 context))
        (output-directory (directory context))
        (script-directory (make-script-directory sub-directory))
        (runs             '()))
    (map nil (lambda+ ((name title command))
               (let ((script/relative
                       (with-output-to-script
                           (stream name script-directory output-directory)
                         (write-string command stream))))
                 (appendf runs (list (list title name script/relative)))))
         steps)

    (write-copy-and-run-commands stream script-directory runs)))

(defmethod write-scripts-and-run-commands ((job      t)
                                           (strategy (eql :one-file-per-builder))
                                           (context  stream-context))
  (let* ((output-directory  (directory context))
         (project-directory (deploy:job-full-name (model:specification job)))
         (script-directory  (make-script-directory project-directory))
         (runs              '()))
    (map nil (lambda (builder)
               (let* ((name    (model:name (aspect builder)))
                      (command (trim-command (deploy:command builder)))
                      (script/relative
                        (with-output-to-script
                            (stream name script-directory output-directory)
                          (write-string command stream))))
                 (appendf runs (list (list name
                                           project-directory
                                           script/relative)))))
         (builders job))

    (write-copy-and-run-commands (stream1 context) script-directory runs)))

(defmethod write-scripts-and-run-commands ((job      t)
                                           (strategy (eql :one-file-for-all-builders))
                                           (context  stream-context))
  (let* ((output-directory  (directory context))
         (project-directory (deploy:job-full-name (model:specification job)))
         (script-directory  (make-script-directory project-directory))
         (script/relative
           (with-output-to-script (stream "builders" script-directory output-directory)
             (map nil (lambda (builder)
                        (let ((name    (model:name (aspect builder)))
                              (command (trim-command (deploy:command builder))))
                          (deploy:print-heading stream (format nil "Aspect ~A" name)) ; TODO should take format-control &rest format-arguments
                          ;; Execute COMMAND in a sub-shell so that
                          ;; e.g. changing the current directory or
                          ;; the environment does not affect the next
                          ;; step.
                          ;;
                          ;; Note that we must not indent the
                          ;; sub-shell command string as that could
                          ;; break HERE documents and maybe other
                          ;; things.
                          (format stream "(~@
                                           ~@<~@;~A~:>~@
                                          )~2%" command)))
                  (builders job)))))

    (write-copy-and-run-commands
     (stream1 context) script-directory
     `(("Builders" ,project-directory ,script/relative)))))
